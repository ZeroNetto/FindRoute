## GeneticRoute

### Постановка задачи

В городе есть N клиентов, для каждого из которых назначена встреча в определенный промежуток времени. Также есть M менеджеров, которым необходимо за оптимальное время посетить всех клиентов. Задача заключается в поиске оптимальных (самых коротких по времени) маршрутов для менеджеров так, чтобы все клиенты были посещены.

### Отвергнутые алгоритмы

- Алгоритм ближайшего соседа
- Муравьиный алгоритм

### Итоговое решение

В качестве итогового решения был выбран генетический алгоритм.

**Генетический алгоритм** - это *эвристический* алгоритм поиска, используемый для решения задач оптимизации и моделирования  путём случайного подбора, комбинирования и вариации искомых параметров с использованием механизмов, аналогичных естественному отбору в природе. Является разновидностью эволюционных вычислений, с помощью которых решаются оптимизационные задачи с использованием методов естественной эволюции, таких как наследование, мутации, отбор и кроссинговер. Отличительной особенностью генетического алгоритма является акцент на  использование оператора «скрещивания», который производит операцию  рекомбинации решений-кандидатов, роль которой аналогична роли  скрещивания в живой природе. 

##### Описание алгоритма

Генетический алгоритм — это в первую очередь эволюционный алгоритм,  другими словами, основная идея алгоритма — скрещивание  (комбинирование). Путем перебора и самое главное отбора получается правильная «комбинация».  

Алгоритм состоит из нескольких этапов:

1. **Формирование новой популяции**. 

   Создается начальная популяция - набор "решений". Такие решения могут оказаться не оптимальными или вовсе некорректными. Задача алгоритма - улучшать эти решения.

2. **Селекция** (отбор).

   Из текущего набора выбираются лучшие "решения" при помощи оценочной функции. Оценочная функция может быть любой, зависеть от различных параметров.

3. **Скрещивание**. 

   Из текущих выбранных "решений" формируются новые но основе хороших данных родителей. Функция скрещивания также может работать по-разному.

4. **Мутация **(необязательный этап).

   После порождения новых решений происходит случайное изменение каких-то из них.

Работа алгоритма после формирования стартового поколения состоит из многократных повторений 2-4 пунктов, пока не выполнится условия выхода. При этом на каждом шаге мы храним "лучшее" с точки зрения условия задачи решение.

### Реализация

#### Вспомогательные классы

* `Time` -  содержит методы для округления `DateTime` с определенной точностью (?)
* `TimeDictionary` - класс-словарь, позволяющий хранить и добавлять время, за которое можно добраться от одного адреса до другого в определенное время. Наследуется от `ITimeDictionary`.
* `Sequence` - ???
* `PriorityQueue` - реализация очереди с приоритетами
* `Entity` - базовый класс для сущностей 
* `ValueType` - базовый класс для типов-значений

#### Ошибки и исключения

* `AcquisitionApiException` - ???
* `FillingDictionaryException` - ???

#### Предметная область

* `Address` - класс адреса
* `Client` - класс клиента. Содержит информацию о месте и времени встречи
* `Manager` - класс менеджера. Содержит информацию о времени работы менеджера, его текущем местоположении.
* `EnvironmentData` - класс, содержащий информацию о конкретном случае задачи. Содержит список клиентов, список менеджеров,  реализацию`ITimeDictionary`.
* `GeneticData` - класс "решения" задачи.

#### Модель

* `ICrosser` -  интерфейс функции скрещивания.
* `IEndCondition` - интерфейс условия выхода.
* `IMutator` - интерфейс фукнции мутации.
* `IEnvironmentDataParser` - интерфейс парсеров данных задачи из файлов.
* `EstimatorBase` - базовый класс оценочной функции решений.
* `RouteFinder` - Основной класс, в котором реализаван генетический алгоритм. В классе такжен реализован метод генерации стартовой популяции.

#### Наши реализации функций алгоритма

* `VisitedClientCountEstimator` - наследуется от `EstimatorBase`. В основе оценки лежит количество посещенных клиентов в решении, на которые менеджер успевает. Также для усреднения времени работы менеджеров допустима вторичная сортировка по максимальному отклонению от среднего значения.
* `EmptyMutator` - реализация `IMutator`. Не производит никаких изменений с популяцией.
* `CountEndEdition` - реализация `IEndCondition`. Выполняет цикл заданное при создании объекта число раз.
* `GreedyCrosser` - реализация `ICrosser`. Основана на выборе у родителей маршрута, на которые успевает каждый из менеджеров, затем собирает из них лучший.
* `GoogleDataParser` - реализация `IEnvironmentDataParser`. Считывает данные о менеджерах и клиентах из двух файлов и заполняет при этом словарь расстояний данными, используя `Google Maps API`. ? расписать подробнее

#### Как пользоваться

```
RouteFinder routeFinder = new RouteFinder(...);
const int startPopulationCount = 10;
const int selectCount = 5;
var startPopulation = routeFinder.GenerateStartPopulation(startPopulationCount).ToList();
GeneticData result = routeFinder.GeneticAlgorithm(startPopulation, selectCount);
```

Вместо многоточия указываются реализации требуемых в конструкторе интерфейсов.

**Для собственной реализации** функций генетического алгоритма достаточно реализовать класс, наследуемый от одного из необходимых интерфейсов (см. пункт _Модель_).

В результате выполнения алгоритма в переменной `result` содержится словарь:

* **ключ** - менеджер; 
* **значение** - список адресов, по которым должен поехать менеджер